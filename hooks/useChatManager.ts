import { useState, useCallback } from 'react';
import { Message, ToolType, TaskStatus, WorkData, Panel } from '../types';
import { generateResponse } from '../services/geminiService';

export const useChatManager = (
    t: any,
    workData: WorkData,
    actions: {
        addMemoryNode: (label: string, group?: number, importance?: number) => void;
        handleAddProject: (p: any) => Promise<void>;
        handleAddTask: (t: any) => Promise<void>;
        setWikiQuery: (q: string) => void;
        toggleTool: (id: ToolType) => void;
        activePanels: Panel[];
    }
) => {
    const [messages, setMessages] = useState<Message[]>([
        { id: '0', role: 'model', content: t.chat.system_welcome, timestamp: new Date() }
    ]);
    const [isThinking, setIsThinking] = useState(false);

    const handleSendMessage = useCallback(async (text: string) => {
        const userMsg: Message = { id: Date.now().toString(), role: 'user', content: text, timestamp: new Date() };
        const newHistory = [...messages, userMsg];
        setMessages(newHistory);
        setIsThinking(true);

        try {
            const response = await generateResponse(text, newHistory);
            let botResponseText = response.text;
            const toolOutputs: string[] = [];

            if (response.functionCalls && response.functionCalls.length > 0) {
                for (const call of response.functionCalls) {
                    if (call.name === 'addMemoryNode') {
                        const { label, group, importance } = call.args as any;
                        actions.addMemoryNode(label, group, importance);
                        toolOutputs.push(`Added concept "${label}" to memory.`);
                        if (!actions.activePanels.some(p => p.id === ToolType.MEMORY)) actions.toggleTool(ToolType.MEMORY);
                    }
                    else if (call.name === 'createProject') {
                        const { title, description, goal } = call.args as any;
                        const newId = `p-${Date.now()}`;
                        const newProject = { id: newId, title, description, goal };
                        await actions.handleAddProject(newProject);
                        toolOutputs.push(`Created project "${title}".`);
                        if (!actions.activePanels.some(p => p.id === ToolType.WORK)) actions.toggleTool(ToolType.WORK);
                    }
                    else if (call.name === 'createTask') {
                        const { title, epicId, status } = call.args as any;
                        const newTask = {
                            id: `t-${Date.now()}`,
                            title,
                            description: 'Generated by AI',
                            status: (status as TaskStatus) || TaskStatus.TODO,
                            epicId: epicId || workData.epics[0]?.id || ''
                        };
                        await actions.handleAddTask(newTask);
                        toolOutputs.push(`Created task "${title}".`);
                        if (!actions.activePanels.some(p => p.id === ToolType.WORK)) actions.toggleTool(ToolType.WORK);
                    }
                    else if (call.name === 'searchWikipedia') {
                        const { query } = call.args as any;
                        actions.setWikiQuery(query);
                        toolOutputs.push(`Searching Wikipedia for "${query}"...`);
                        if (!actions.activePanels.some(p => p.id === ToolType.WIKIPEDIA)) actions.toggleTool(ToolType.WIKIPEDIA);
                    }
                }
                if (!botResponseText && toolOutputs.length > 0) botResponseText = toolOutputs.join(' ');
                else if (toolOutputs.length > 0) botResponseText += `\n\n[System Update]: ${toolOutputs.join(' ')}`;
            }

            setMessages(prev => [...prev, { id: (Date.now() + 1).toString(), role: 'model', content: botResponseText || "Processed.", timestamp: new Date() }]);
        } catch (err) {
            console.error(err);
            setMessages(prev => [...prev, { id: Date.now().toString(), role: 'model', content: "Sorry, I encountered an error processing that request.", timestamp: new Date() }]);
        } finally {
            setIsThinking(false);
        }
    }, [messages, actions, workData.epics]);

    return {
        messages,
        setMessages,
        isThinking,
        handleSendMessage
    };
};
